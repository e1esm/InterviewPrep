### Ambassador: 
позволяет перенести client connectivity tasks: мониторинг, логинг, маршрутизация, обеспечение безопасности на proxy сервис. 
	- Проблемы и вопросы при реализации этого паттерна:
		- Использование прокси сопровождается дополнительной задержкой.
	- Использовать шаблон, когда:
		- Нужно выполнить параллельное запросу действие
		- Нужно создать общий набор клиентских функций между сервисами которые написаны на разных языках или платформах
		- Если требуется поддержка облачного или кластерного коннекшина для приложения, которое устарело или по другим причинам не поддается доработке.
	- Не использовать:
		- Если критически важен пинг в сети для запросов.
		- Если все клиентские функции подключения реализованы на одном языке.
		- Если функции подключения невозможно обобщить или требуется более глубокая интеграция с клиентским приложением.
### Circuit Breaker:
паттерн позволяет предотвратить попытки приложения выполнять операцию, которая скорее всего завершится неудачно, что позволяет продолжить работу дальше, не тратя ресурсы до момента устранения проблемы. Этот паттерн так же позволяет узнать была ли устарнена неисправность.
	- Состояния Circuit Breaker:
		- Closed - Запрос приложения перенаправляется на операцию, прокси-сервер ведет подсчет числа сбоев и если вызов операции не завершилс удачно - прокси-сервер увеличивает число. Если число сбоев превышает заданный порог - сервер переводится в состояние Открытый.
		- Half-Open - ограниченному числу запросов от приложения разрешено проходить через операцию и вызвать ее. Если эти запросы выполняются успешно, предполагается, что ошибка, которая ранее вызывала сбой - устранена, а автоматчиеский выключатель переходит в состояние `Закрытый`.
		- Open - запрос от приложения немедленно завершает с ошибкой и исключение возвращается в приложение
Шаблон Circuit Breaker дает системе время восстановиться, снижает влияние на производительностью
- Использовать, когда:
	- Нужно предотвратить попытки вызова приложением удаленного сервиса или получения доступа к общему ресурсу, если эта операция скорее всего завершится ошибкой.
- Не использовать, когда:
	- Для обработки доступа к локальным закрытым ресурсам в приложении, например, в структуре данных памяти. В этой среде при использовании Circuit Breaker нагрузка в системе возрастает
	- В качестве замены для обработки исключений в бизнес-логике.


### CQRS (Command Query Responsibility):
![[Pasted image 20230925014729.png]]
- Command ориентированы на задачи, а не на данные
- Command может помещаться в очередь для асинхронной обработки, а не обрабатываться синхронно.
- Query никогда не должен изменять базу данных, Query возвращает DTO, который не инкапсулирует знания предметной области.

Преимущества CQRS:
- Независимое масштабирование - раздельное масштабирование рабочих нагрузок чтения и записи, снижая риск конфликтов блокировки
- Оптимизированные схемы данных - Для query применить схему, оптимизированную для запросов, а для commands - оптимизированную для обновлений.
- Безопасность - разделение операций позволит настроить более гибкую систему доступа.
- Разделение проблем - разделение операций позволяет получить более гибкие и простые в обслуживании классы.
- Более простые запросы - сохраняя в базе данных для чтения materialized view, вы предотвратите использование сложных запросов и join'ов.
- Не требуют 2 хранилища данных - отдельные хранилища для query и command это одна из реализаций, а не обязательное требование.

Недостатки CQRS:
- Сложность
- Обмен сообщениями - месседж брокеры часто применяются для обработки команд и публикации событий. Это означает, что нужно реализовывать обработку сбоев и дубликатов при передаче сообщений.
- Eventual Consistency: если вы разделяете базы данных для чтения и записи - в базе данных для чтения могут оставаться устаревшие данные. БД для чтения должна быть up to date, чтобы отражать изменения из БД для записи и может быть трудно трекать, когда пользователь сделал запрос на основе устаревших данных с БД для чтения.


### Event Sourcing:
Event Sourcing - это архитектурный паттерн, в котором все изменения, вносимые в состояние приложения сохраняются в своей последовательности. Эти записи служат как источник для получения текущего состояния, так и audit-log'ом того, что происходило в системе.
Данный подход способствует децентрализованному изменению и чтению данных. Такая архитектура хорошо масштабируется и подходит для систем, которые уже работают с событиями.

Преимущества Event Sourcing:
- События immutable
- События могут раниться на фоне
- ES может помочь в предотвращении конкфликтов, вызванных параллельными апдейтами, тк исключает необходимость непосредственного обновления объектов в Data Store.
- Append-only storage предоставляет audit-log, который можно использовать для мониторинга событий, произошедших в Data Store.
- Каждое событие могут обрабатывать несколько задач.
Недостатки ES:
- Самые большие сложности связаны с построением мышления разработчиков.
- При ES много сил тратится на моделирование событий.
- Для простой логики ES может быть легким, а для сложной проблематичным.
- Важно учитывать структуру событий.


### Leader Selection:
Leader Selection - это паттерн, в основе которого лежит алгоритм с идеей предоставления особых полномочий одному процессу, узлу, потоку, объекту или человеку в распределенной системе. К таким особым полномочиям относится возможность назначать работу, вносить изменения и т.д.
Выбор лидера - мощный инструмент для повышения эффективности снижения уровня координации, упрощения архитектур и сокращения количества операций.
Преимущества LS:
- Улучшает производительность систем или снижает затраты за счет согласованного кэша данных
- Обеспечивает клиентам согласованность, потому что позволяет видеть и контролировать все изменения состояния системы.
Недостатки LS:
- Может стать единой точкой отказа
- Единая точка масштабирования системы
- Единая точка надежности
- Частичные развертывания затруднительно применить в системе с выбранным лидером.


### PubSub:
Издатель-подписчик - поведенческий паттерн проектирования передачи сообщений, в котором отправители, напрямую не привязаны программным кодом отправки сообщений к подписчикам. Вместо этого сообщения делятся на классы и не содержат сведений о своих подписчиках, если таковые есть. Аналогичным образом подписчики имеют дело с одним или несколькими классами сообщений, абстрагируюсь от конкретных издателей.



