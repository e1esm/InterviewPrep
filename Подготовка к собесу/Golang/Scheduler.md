

## Планировщик OS:
Каждая запущенная программа создает процесс, к которому присваивается свой поток. У процесса может быть несколько потоков, выполняемых независимо друг от друга. Потоки могут выполняться конкурентно(на одном ядре) и параллельно(каждый на разных ядрах). Потоки сохраняют свое собственное состояние, чтобы обеспечить безопасное и независимое выполнение инструкций.
Планировщик отвечает за то, что ядра не простаивали, если есть потоки, которые могут выполняться. Его задача - создать иллюзию того, что все потоки выполняются одновременно. Планировщик запускает потоки с более высоким приоритетом по сравнению с потоками с более низким приоритетом. Планировщик минимизирует задержки планирования. Является недетерминированным.


## С чем взаимодействует планировщик OS:
- Состояния потоков (Thread States):
	- Waiting - поток находится в состоянии ожидания
	- Runnable - потоку требуется время на ядре.
	- Executing - поток размещен на ядре и выполняет свои машинные инструкции
- Типы выполняемой работы (Types of Work):
	- CPU-Bound - это работа, в которой поток никогда не будет в состоянии ожидания.
	- IO-Bound - это работа, заставляющая потоки входить в состояние ожидания.
- Переключение контекста:
	- Физический акт обмена потоками в ядре. Переключение происходит в момент, когда планировщик вытягивает Executing поток из ядра и заменяет его Runnable потоком. Вытащенный поток может вернуться в состояние Runnable (если он может работать) или в состояние Waiting (если изменен из-за запроса типа IO-bound). Переключение контекста - дорогая операция.

Переключение контекста будет преимуществом, если есть программа, ориентированная на работу с IO-Bound. Как только поток переходит в состояние ожидания - он тут же заменяется другим потоком в состоянии Runnable, что позволяет ядру всегда выполнять работу.
Если работа завязана на CPU-Bound, то переключение будет ухудшать производительность. 


## Планировщик Go:
Планировщик Go, как и OS недетерменирован.

Планировщик Go работает со следующими сущностями:
- P, M, G
	- P - логический процессор (не железо). Условный контекст, который объединяет поток операционной системы М и очередь горутин. Количество горутин, привязанных к P неограничено. По умолчанию количество P берется из значения переменной среды GOMAXPROCS и равно количеству логических ядер компьютера.
	- M - поток OS. Закреплен за P и имеет с ним отношение один к одному.
	- G - горутина.
- Goroutine - каждой программе Go дается начальная горутина. Goroutine - потоки уровня приложения. Потоки OS располагаются на ядре OS, а горутины на потоках OS.
- Состояния потоков (Thread States):
	- Waiting - горутина остановлена и ожидает своего продолжения работы
	- Runnable - горутине нужно время на М, чтобы можно было выполнять инструкции.
	- Running - горутина исполняет свои инструкции.
- Переключение контекста - более легковесная операция, чем переключения контекста OS.
- GRQ, LRQ:
	- В планировщике Go есть две разные очереди выполнения: Gloabl Run Queue - GRQ и локальная очередь выполнения Local Run Queue - LRQ. Каждому P присваивается LRQ, которая управляет горутинами, назначенными для выполнения на P. Эти горутины по очереди включаются и выключаются в зависимости от контекста М, назначенного этому P.
	- GRQ предназначен для горутин, которые еще не были назначены для какого-либо P. Существует процесс перемещения горутин из GRQ в LRQ.

![[Pasted image 20230921031146.png]]
В левом углу глобальная очередь горутин, в которой находится 1 горутина. В центре находится поток операционной системы M, расположенный на ядре Core, и к этому потоку прикреплен логический процессор P. Одна горутина находится в состоянии Running и 3 в состоянии Runnable.



## Work stealing:
Планировщик Go работает по принципу "кражи работы".
![[Pasted image 20230921031428.png]]
На рисунке многопоточная программа с двумя логическими процессорами, каждый из которых обслуживает по 4 горутины. Глобальная очередь с единственной горутиной.

![[Pasted image 20230921031540.png]]
У потока P1 больше нет горутин. Ни в состоянии Running, ни Runnable. А у P2 - 4 горутины -> поток P1 украдет у второго потока половину Runnable горутин.

![[Pasted image 20230921031724.png]]
Если же у второго потока не останется горутин, а у первого потока останется только одна - то второй поток возьмет горутину из GRQ:
![[Pasted image 20230921031808.png]]