

### DDL vs DML:
DDL - Data Definition Language - подмножество языка SQL, используемое для определения структуры базы данных и ее объектов, такие как таблицы, представления, индексы и процедуры - CREATE, ALTER, DROP, TRUNCATE, RENAME.

DML - Data Manipulation Language - подмножества языка SQL, которое используется для манипулирования данными в базе данных - SELECT, INSERT, UPDATE, DELETE
### Нормализация
Нормализация - это процесс приведения базы данных к нормальным формам с целью избавления от логической избыточности, а декомпозиция - это одна из вариаций нормализации.

### 1я нормальная форма:
Если все атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений в таблице


### 2я нормальная форма:
Отношение находится во 2НФ, если оно находится в 1Нф и каждый не ключевой атрибут неприводимо зависит от первичного ключа.

### 3я нормальная форма:
Отношение находится в 3НФ, когда оно находится во 2НФ и в таблицах отсутствует транзитивная зависимость.


### 4я нормальная форма:
Отношение находится в 4НФ, если оно находится в 3НФ и нет многозначных зависимостей - где столбец с первичным ключом имеет связь один-ко-многим со столбцом, который не является ключом. Эта нормальная форма устраняет некорректные отношения многие-ко-многим.

### 5я нормальная форма:
Отношение находится в 5НФ, если оно находится в 4НФ и все таблицы разбиты на таблицы меньше до тех пор, пока нельзя будет воссоздать оригинальную таблицу путем объединения малых таблиц.


### 6я нормальная форма:
Отношение находится в 6НФ, если оно находится в 5НФ и каждое ограничение в связях между таблицами зависит только от ограничений ключа и ограничений домена, где домен - набор допустимых значений для столбца.


### Разница между NoSQL и SQL:
Иногда можно добиться большего быстродействия у первого языка. Преимущество есть в скорости выполнения запросов - это связано с отсутствием связей и конкретной схемы NoSQL.
MongoDB может выиграть у PostgreSQL в запросах, которые подразумевают много связей и за которым постгрес полезет в другие таблицы, которые могут оказаться очень большими.


### Транзакция:
Транзакция - это операция в базе данных.
Она может состоять и из нескольких операций - в этом ключе - это логически целостная процедура, в которой должны быть выполнены либо все операции, либо ни одна из них.

Транзакция начинается с команды BEGIN и заканчивается командой COMMIT либо отменяется командой ROLLBACK.


### ACID у транзакций:
Согласно теории БД, транзакции должны обладать следующими свойствами:
1) Атомарность (atomicity). Это свойство означает, что либо транзакция будет зафиксирована в базе данных полностью, т.е. будут зафиксированы результаты выполнения всех ее операций, либо не будет зафиксирована ни одна операция транзакции.
2) Согласованность (consistency) - это свойство предписывает, чтобы в результате успешного выполнения транзакции база данных была переведена из одного согласованного состояния в другое согласованное состояние.
3) Изолированность (isolation) - во время выполнения выполнения транзакции другие транзакции должны оказывать по возможности минимальное влияние на нее.
4) Долговечность (durability) - После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в БД и впоследствии могут быть извлечены из нее, независимо от последующих возможных сбоев в работе системы.

Для обозначения всех 4х свойств используется сокращение: ACID.




### Выполнение транзакций:
Транзакции можно выполнять последовательно или параллельно:
Во втором случае могут возникнуть следующие проблемы:
1) Потерянное обновление (lost update): Когда разные транзакции одновременно изменяют одни и те же данные - то после фиксации изменений может оказаться, что одна транзакция перезаписала данные, обновленные и зафиксированные другой транзакцией.
2) Грязное чтение (dirty read): Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась. Если параллельная транзакция будет в итоге отменена - тогда окажется, что первая транзакция прочитала данные, которых нет в системе.
3)  Неповторяющееся чтение (non-repeatable read) - При повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные - в результате тот же самый запрос выдает другой результат.
4) Фантомное чтение (phantom read) - Транзакция повторно выбирает множество строк в соответствии с одним и тем же критерием. В интервале времени между выполнением этих выборок другая транзакция добавляет новые строки и успешно фиксирует изменения. В результате при выполнении повторной выборки первой транзакции может быть получено другое множество строк.
5) Аномалия сериализации (serialization anomaly) - Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одного из  возможных вариантов упорядочения этих транзакций, если бы они выполнялись последовательно.

### Аномалия сериализации:
Для двух транзакций возможны только 2 варианта упорядочения при их последовательном выполнении:
1) А -> B
2) B -> A
Результаты двух вариантов в конечном итоге могут не совпадать.

Сериализация двух транзакций при их параллельном выполнении означает, что полученный результат будет соответствовать одному из возможных вариантов упорядочения транзакций 2100 у.е. либо 2200 у.е - не иначе. Соответственно, аномалия сериализации - несоответствие результата ни одному из вариантов.
В таком случае - нельзя сказать точно, какой из вариантов реалиазован.

### Уровни транзакций:
1) Read uncommited - самый низкий уровень изоляции - допускается чтении незафиксированных данных. В PostgreSQL требования, предъявляемые к этому уровню выше - чтение грязных данных не допускается.
2) Read Commited - не допускается чтение грязных данных. Транзакция может видеть только те незафиксированные изменения данных, который произведены в ходе выполнения ее самой.
3) Repeatable Read - не допускается чтение грязных данных и неповторяющееся чтение. В PostgreSQL на этом уровне не допускается также фантомное чтение.
4) Serializable: Не допускается ни один из феноменов выше. Конкретный уровень изоляции обеспечивает сама СУБД с помощью своих внутренних механизмов.

### Блокировки:
Кроме поддержки уровней изоляции транзакций, многие СУБД позволяют также создавать блокировки данных как на уровне отдельных строк, так и на уровне целых таблиц.
Команда `SELECT` имеет предложение `FOR UPDATE`, которое позволяет заблокировать отдельные строки таблицы с целью их последующего обновления.
Если одна транзакция заблокировала строки с помощью этой команды - параллельные транзакции не смогут заблокировать эти же строки до тех пор, пока первая транзакция не завершится, сняв блокировку.


### Индексы:
По умолчанию команда `CREATE INDEX` создает индексы типа B-дерево (эффективны в большинстве случаев)
Виды индексов:
- B-дерево - используется планировщиком всегда, когда в запросе есть сравнения.
- хэш - всякий раз, когда используется знак сравнения `=`, планировщик будет использовать этот индекс.
- GiST - полезны для индексирования геометрических данных и полнотекстового поиска.
- SP-GiST - роутинг IP и телефонии, мультмедиа, 
- GIN - используются на колонках с типами данных: hstore, array, jsonb, и range types.
- BRIN - используется в очень больших таблицах, где использования B-дерева было бы непрактичным. Ставится на колонку с linear sort последовательностью - дата создания и т.п.

Способы создания индексов:
- Индекс по столбцу
- Индекс по нескольким столбцам
- Уникальный индекс
- Индекс на основе выражения
- Частичный индекс

Случаи, когда индексы нежелательны:
- В маленьких таблицах
- Таблицы, в которые часто происходит запись или обновление
- На колонках, в которых частое значение - NULL
- на колонках, которые часто манипулируются.


### Планировщик:
Встроенный в СУБД механизм, перед выполнением запроса формирует его план. Посмотреть план можно с помощью команды EXPLAIN. Планировщиком можно управлять с целью просмотра логики его работы и дальнейшей оптимизации запросов.

### Оптимизация запросов:
Повлиять на скорость выполнения запросов можно различными способами:
- Изменить запрос
- Обновить статистику планировщика, на основе который строит планы
- Денормализировать: создать временные таблицы или создать индексы
- Изменение параметров планировщика, отвечающих за выбор метода доступа к данным: (enable_seqscan, enable_indexscan, enable_indexonlyscan, enable_bitmapscan)
- Изменение параметров планировщика, отвечающих за способ соединения наборов строк: (enable_nestloop, enable_hashjoin, enable_mergejoin)

### Концепции масштабируемости БД
1) Шардирование
2) Репликация

В обоих случаях подразумевается наличие нескольких инстансов БД

Для шардирования мы определяем срезы строк, которые будут храниться в конкретном инстансе, например для первого - это с 1 по 10_000, для второго 10_001 по 20_000 и т.д.

Репликация подразумевает создание одного инстанса контроллера и нескольких инстансов-нод. То есть по сути это полное копирование СУБД на другой сервер. Таким образом контроллер сам будет решать в какую ноду и что ему записывать.

По статистике SELECT выглядит во много чаще INSERT'а, из-за чего репликация выглядит привлекательнее.



### EXPLAIN ANALYZE DROP POSTGRES:
Данная команда удалит главную БД из-за `EXPLAIN ANALYZE`. Если бы было просто `EXPLAIN` - нет.


### Оператор JOIN:
JOINS используется для извлечения данных из нескольких таблиц. Этот оператор используется каждый раз, когда идет извлечение из двух и более таблиц.
Виды JOIN'ов:
- INNER JOIN - возвращает все строки из нескольких таблиц, где выполняется условие соединения.![[Pasted image 20230925005219.png]]
- LEFT OTUER JOIN - этот тип соединения используется для возвращения всех строк из таблиц с левосторонним соединением указанным в условии ON.![[Pasted image 20230925005413.png]]
- RIGHT OUTER JOIN - используется для соединения всех строк из таблицы с правосторонним соединением, указанным в ON![[Pasted image 20230925005502.png]]
- FULL OUTER JOIN - возвращает все записи из 2х таблиц.![[Pasted image 20230925005558.png]]
- CROSS JOIN - возвращает количество строчек, равное n * m![[Pasted image 20230925005757.png]]
